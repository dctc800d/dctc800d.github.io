# [没有上司的舞会](https://www.luogu.com.cn/problem/P1352)

## 题目描述

某大学有 $n$ 个职员，编号为 $1\ldots n$。

他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。

现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。

所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。

## 输入格式

输入的第一行是一个整数 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。

第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。

## 输出格式

输出一行一个整数代表最大的快乐指数。

## 样例 #1

### 样例输入 #1

```
7
1
1
1
1
1
1
1
1 3
2 3
6 4
7 4
4 5
3 5
```

### 样例输出 #1

```
5
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\leq n \leq 6 \times 10^3$，$-128 \leq r_i\leq 127$，$1 \leq l, k \leq n$，且给出的关系一定是一棵树。

---

---

---

# 思路分析

这道题**很难**，但~~很简单~~。

经过~~两秒半的~~审题和思考，大家都能看出来职工们的关系为**一棵以校长为根的树**，同时，我们一看到**使快乐指数最大**这类的文字，就知道了这是一个典型的动规题目。又是树的，又是动规的，我寻思着，这不就是一道典型的树形动规题目吗？！

---

先科普一下树形动规。

（~~几年前，我刚看到这道题时，也知道是树形动规，但是就是不知道怎么做，后来一想，按当初我的水平，怎么可能做出来这种绿题呢？！~~）

废话少做，言归正传：

> 树形 DP，即在树上进行的 DP。由于树固有的递归性质，树形 DP 一般都是递归进行的。
> 
> ——OI-Wiki

---

再看向这道题。

既然是动规题，那么就要构建一个动规数组。

仔细看，发现构建一个二维数组不太现实。因为我们的限制条件不是什么“$n$元钱”，也不是什么“$n$秒钟”，而是**对于每一个职工，要么不让他参加舞会，要么不然他的直接上司参加舞会，或者两个都别参加也行，总之他们其中的一个不能参加舞会**。所以我们是没有办法构建一个二维数组的，因为根本没有第一维的限制常量。考虑使用一维数组。

可以这样：

对于职工$i$，分两种情况：

1. 不选，最大快乐值为$f_i$；
2. 选，最大快乐值为$g_i$；

最后，程序结束前，输出$max(f_i,g_i)$即可。

~~等等，你还没说转移方程呢！~~

别急，慢慢来。

设职工$i$的快乐值为$r_i.w$，存有所有直接下属编号的$vector$为$r_i.v$，即有：

1. 不选，即对于他的每个直接下属，可以取他的选或不选中的快乐值最大的那个，但不能加上自己的快乐值（因为不选嘛），即为：$f_i=\Sigma_{j=0}^{r_i.v.size()-1}max(f_{r_i.v_j},g_{r_i.v_j})$；
2. 选，即对于他的每个直接下属，都得选不选他的快乐值，但最后还要加上自己的快乐值（因为选嘛），即为：$g_i=(\Sigma_{j=0}^{r_i.v.size()-1}f_{r_i.v_j})+r_i.w$

于是，代码便出来了。

---

# 交流电(AC)代码：

```cpp
#include<iostream>
#include<vector>
#include<bitset>
using namespace std;
struct s
{
    int w{};
    vector<int>v;
}r[8192];
int n, o, f[8192], g[8192];
bitset<8192>b;
static void h(int x)
{
    for (int i{}; i < r[x].v.size(); i++)
        h(r[x].v[i]), f[x] += (f[r[x].v[i]] > g[r[x].v[i]] ? f[r[x].v[i]] : g[r[x].v[i]]), g[x] += f[r[x].v[i]];
}
int main()
{
    cin >> n;
    for (int i{ 1 }; i <= n; i++)
        cin >> r[i].w, g[i] = r[i].w;
    for (int i{ 1 }; i < n; i++)
    {
        int x, y;
        cin >> x >> y;
        r[y].v.push_back(x);
        b[x] = true;
    }
    for (int i{ 1 }; i <= n; i++)
        if (!b[i])
        {
            o = i;
            break;
        }
    h(o);
    cout << (f[o] > g[o] ? f[o] : g[o]);
    return 0;
}
```

谢谢[您](https://www.luogu.com.cn/user/63075)的观看！


