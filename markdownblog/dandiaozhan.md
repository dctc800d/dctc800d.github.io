# [【模板】单调栈](http://luogu.com.cn/problem/P5788)

## 题目背景

模板题，无背景。

2019.12.12 更新数据，放宽时限，现在不再卡常了。

## 题目描述

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个正整数 $a_{1\dots n}$。

## 输出格式

一行 $n$ 个整数表示 $f(1), f(2), \dots, f(n)$ 的值。

## 样例 #1

### 样例输入 #1

```
5
1 4 2 3 5
```

### 样例输出 #1

```
2 5 4 5 0
```

## 提示

【数据规模与约定】

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

---

---

本题是一道单调栈的模板题。

首先说说什么是单调栈。

> 何为单调栈？顾名思义，单调栈即满足单调性的栈结构。——OI-Wiki

~~那什么是单调呢？~~

> 当函数 f(x) 的自变量在其定义区间内增大（或减小）时，函数值f(x)也随着增大（或减小），则称该函数为在该区间上具有单调性。——百度百科

其实很简单，只要序列$r$满足以下条件，就可以被称为单调的：

- $\forall i,0<i<|r|,r_i<r_{i+1}$（单调递增）
- $\forall i,0<i<|r|,r_i\le r_{i+1}$（单调不严格递增）
- $\forall i,0<i<|r|,r_i>r_{i+1}$（单调递减）
- $\forall i,0<i<|r|,r_i\ge r_{i+1}$（单调不严格递减）

~~那什么是**栈**呢？~~

> 堆栈又名栈（stack），它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。——百度百科

现在把术语解释清楚了，下面我们就来康康单调栈有什么用。

一般来说，单调栈用来$O(n)$时间复杂度查找序列上每个元素左/右边第一个大于/小于/大于等于/小于等于它的元素。

在知道单调栈之前，我们写这样的程序是这样写的（以右边大于为例）：

```cpp
#include <bits/extc++.h>
#define int long long
using namespace std;
using namespace __gnu_pbds;
int r[65536], n;
signed main()
{
    scanf("%lld", &n);
    for (int i{1}; i <= n; i++)
        scanf("%lld", r + i);
    for (int i{1}; i <= n; i++)
    {
        bool f{};
        for (int j{i + 1}; j <= n; j++)
            if (r[j] > r[i])
            {
                printf("%lld ", j);
                f = true;
                break;
            }
        if (!f)
            printf("0 ");
    }
    return 0;
}
```

通过分析，我们可以得知，这段代码的时间复杂度为$O(n^2)$（双重循环），显然会TLE，所以很多年以后，珂学家们发现单调栈可以对这段代码进行优化，我现在就拿`1 1 4 5 1 4 1 9 1 9 8 1 0`作为$r$数组的值告诉大家如何用单调栈解决这个问题。

1. 栈内没有元素，$r_1$进栈；

2. 栈顶元素不小于$r_2$，$r_2$进栈；

3. 栈顶元素小于$r_3$，$r_3$把栈顶元素挤出去，并成为它的答案；

4. 栈顶元素还是小于$r_3$，$r_3$把栈顶元素挤出去，并成为它的答案；

5. 栈内没有元素，$r_3$进栈；

6. 栈顶元素小于$r_4$，$r_4$把栈顶元素挤出去，并成为它的答案；

7. 栈内没有元素，$r_4$进栈；

8. 栈顶元素不小于$r_5$，$r_5$进栈；

9. 栈顶元素小于$r_6$，$r_6$把栈顶元素挤出去，并成为它的答案；

10. 栈顶元素不小于$r_6$，$r_6$进栈；

11. 栈顶元素不小于$r_7$，$r_7$进栈；

12. 栈顶元素小于$r_8$，$r_8$把栈顶元素挤出去，并成为它的答案；

13. 栈顶元素还是小于$r_8$，$r_8$把栈顶元素挤出去，并成为它的答案；

14. 栈顶元素还是小于$r_8$，$r_8$把栈顶元素挤出去，并成为它的答案；

15. 栈内没有元素，$r_8$进栈；

16. 栈顶元素不小于$r_9$，$r_9$进栈；

17. 栈顶元素小于$r_{10}$，$r_{10}$把栈顶元素挤出去，并成为它的答案；

18. 栈顶元素不小于$r_{10}$，$r_{10}$进栈；

19. 栈顶元素不小于$r_{11}$，$r_{11}$进栈；

20. 栈顶元素不小于$r_{12}$，$r_{12}$进栈；

21. 栈顶元素不小于$r_{13}$，$r_{13}$进栈；

最后，栈内还剩下$r_8$、$r_{10}$、$r_{11}$、$r_{12}$、$r_{13}$，它们没有答案。

至此，我们用$O(n)$的时间复杂度算出来了序列上每个元素右边第一个大于它的元素。左边、小于/大于等于/小于等于同理。这就是单调栈的用法。

最后，贴上交流电(AC)代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int r[3000006],n,ans[3000006];
stack<int>s;
signed main()
{
    cin>>n;
    for(int i {1}; i<=n; i++)
        cin>>r[i];
    for(int i {1}; i<=n; i++)
    {
        while(!s.empty()&&r[s.top()]<r[i])
            ans[s.top()]=i,s.pop();
        s.push(i);
    }
    for(int i {1}; i<=n; i++)
        cout<<ans[i]<<' ';
    return 0;
}
```

谢谢大家的观看！

**谢谢[谢博士](https://www.luogu.com.cn/user/63075)的指导！**
